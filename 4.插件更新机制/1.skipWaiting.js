// 刷新当前页面，缓存立即生效

// 优点：用户无感知
// 缺点：潜在问题，可能会导致异步资源请求失败

// sw.js

self.addEventListener('install', event => {
    self.skipWaiting()
    // 预缓存其他静态内容
});

// 这样可以让新的 SW “插队”，强制令它立刻取代老的 SW 控制所有页面，而老的 SW 被“斩立决”，简单粗暴。
// 方案实在是太容易想到也太容易实现了，诱惑极大。

可惜这个方案是有隐患的。我们想象如下场景：

1.一个页面 index.html 已安装了 sw.v1.js （实际地址都是 sw.js，只是为了明显区分如此表达而已）


2.用户打开这个页面，所有网络请求都通过了 sw.v1.js，页面加载完成。


3.因为 SW 异步安装的特性，一般在浏览器空闲时，他会去执行那句 navigator.serviceWorker.register。这时候浏览器发现了有个 sw.v2.js 存在，于是安装并让他等待。


4.但因为 sw.v2.js 在 install 阶段有 self.skipWaiting()，所以浏览器强制退休了 sw.v1，而是让 sw.v2 马上激活并控制页面。


5.用户在这个 index.html 的后续操作如有网络请求，就由 sw.v2.js 处理了。

很明显，同一个页面，前半部分的请求是由 sw.v1.js 控制，而后半部分是由 sw.v2.js 控制。
这两者的不一致性很容易导致问题，甚至网页报错崩溃。
比如说 sw.v1.js 预缓存了一个 v1/image.png，而当 sw.v2.js 激活时，通常会删除老版本的预缓存，转而添加例如 v2/image.png 的缓存。
所以这时如果用户网络环境不畅或者断网，或者采用的是 CacheFirst 之类的缓存策略时，浏览器发现 v1/image.png 已经在缓存中找不到了。
即便网络环境正常，浏览器也得再发一次请求去获取这些本已经缓存过的资源，浪费了时间和带宽。
再者，这类 SW 引发的错误很难复现，也很难 DEBUG，给程序添加了不稳定因素。